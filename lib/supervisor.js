'use strict';

var EventEmitter = require('events').EventEmitter;
var stream = require('stream');
var _ = require('lodash');
var copper = require('@relinklabs/copper');
var actor = require('./actor');
var supervisor = {};

/*
 * Keeps track of number of errors in a row before any successes
 * and grinds everything to a halt if the errors exceed to provided
 * maximum number.
 */
supervisor._trackErrors = function _trackErrors(maxErrors) {
  var ee = new EventEmitter();
  var errors = 0;

  ee.on('success', function (msg) {
    return errors = 0;
  });
  ee.on('error', function (err) {
    if (++errors > maxErrors) {
      throw new Error('grind this whole shit to a halt');
    };
  });

  return ee;
};

/*
 * recursing function that fires up actors
 */
supervisor._startActors = function startActors(num, src, dest, rc, ee, config, endCb) {
  if (num === 0) {
    return;
  };

  actor.start(src, dest, config.transform).on('success', function (msg) {
    return ee.emit('success', msg);
  }).on('error', function handleErrors(err) {

    // write message back to the recycle/error queue
    var input = err.originalInput;
    rc.write(input) || rc.once('drain', rc.write(input));

    // write to the error stream and recurse to restart a single actor.
    ee.emit('error', err);
    startActors(1, src, dest, rc, ee, config, endCb);
  }).on('end', endCb);

  startActors(--num, src, dest, rc, ee, config, endCb);
};

/*
 * Keeps track of finished actors, returns promise that resolves when all
 * started actors succesfully end.
 */
supervisor._runProxies = function runProxies(src, dest, config, rc) {
  var num = config.number;
  var errorCount = config.errorCount || 10;
  var resolve;

  if (!num) {
    throw new Error('config object must include the number of workers to start!');
  }

  var endCb = function endCb() {
    return --num < 1 && resolve();
  };
  var ee = supervisor._trackErrors(errorCount);
  supervisor._startActors(num, src, dest, rc, ee, config, endCb);

  return new Promise(function (_resolve, reject) {
    return resolve = _resolve;
  });
};

/**
 * Supervisor starts actors, running the proxy actor processes, monitoring
 * them to see when they are either all finished, or have excessive errors. If they
 * have excessive errors, the supervisor will intentionally throw and stop the system.
 * When they come to the end of their queue, the supervisor will wait until the queue
 * starts again, then start them up again.
 *
 * @param {Object} config number = number of actors to start,
 * transform = transform!
 * errorCount = amount of errors in a row before it shuts down
 * @param {Stream} rc optional recycle stream for messages that errored.
 * @param {Stream} src for use only if not piping, then its the src stream.
 * @param {Stream} dest for use only if not piping, then its the dest stream
 * @returns {Stream} Duplex Stream that can be piped into and out of
 */
supervisor.start = function startSupervisor(config, rc, src, dest) {

  // if we are passed in a readable stream, rather than creating on ourselves,
  // the user might pass it in in flow mode, which we don't want, so we stop it.
  src && !src.isPaused() ? src.pause() : null;

  // if we are not given streams directly, then we're being piped, in which
  // case we create passthrough streams so we have a read() and write()
  // interface with proper backpressure throughout the rest of our process.
  var streams = copper.fanout();
  src = src || streams.src;
  dest = dest || streams.dest;

  src.on('readable', handleNewData);

  function handleNewData() {
    supervisor._runProxies(src, dest, config, rc).then(function () {
      return startSupervisor(config, rc, src, dest);
    });

    // remove listener so that our process  doesn't get restarted
    // until all actors have fully stopped.
    src.removeListener('readable', handleNewData);
  };

  return streams.ext;
};

module.exports = supervisor;
//# sourceMappingURL=data:application/json;base64,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QXhCLEVBQTZCLEdBQTdCLEVBQWtDLElBQWxDLEVBQXdDLEVBQXhDLEVBQTRDLEVBQTVDLEVBQWdELE1BQWhELEVBQXdELEtBQXhELEVBWG1FOztBQWFuRSxTQUFPLElBQUksT0FBSixDQUFZLFVBQUMsUUFBRCxFQUFXLE1BQVg7V0FBc0IsVUFBVSxRQUFWO0dBQXRCLENBQW5CLENBYm1FO0NBQTVDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdDekIsV0FBVyxLQUFYLEdBQW1CLFNBQVMsZUFBVCxDQUEwQixNQUExQixFQUFrQyxFQUFsQyxFQUFzQyxHQUF0QyxFQUEyQyxJQUEzQyxFQUFpRDs7OztBQUlsRSxTQUFPLENBQUMsSUFBSSxRQUFKLEVBQUQsR0FBa0IsSUFBSSxLQUFKLEVBQXpCLEdBQXVDLElBQXZDOzs7OztBQUprRSxNQVM5RCxVQUFVLE9BQU8sTUFBUCxFQUFWLENBVDhEO0FBVWxFLFFBQU0sT0FBTyxRQUFRLEdBQVIsQ0FWcUQ7QUFXbEUsU0FBTyxRQUFRLFFBQVEsSUFBUixDQVhtRDs7QUFhbEUsTUFBSSxFQUFKLENBQU8sVUFBUCxFQUFtQixhQUFuQixFQWJrRTs7QUFlbEUsV0FBUyxhQUFULEdBQTBCO0FBQ3hCLGVBQ0csV0FESCxDQUNlLEdBRGYsRUFDb0IsSUFEcEIsRUFDMEIsTUFEMUIsRUFDa0MsRUFEbEMsRUFFRyxJQUZILENBRVE7YUFBTSxnQkFBZ0IsTUFBaEIsRUFBd0IsRUFBeEIsRUFBNEIsR0FBNUIsRUFBaUMsSUFBakM7S0FBTixDQUZSOzs7O0FBRHdCLE9BT3hCLENBQUksY0FBSixDQUFtQixVQUFuQixFQUErQixhQUEvQixFQVB3QjtHQUExQixDQWZrRTs7QUF5QmxFLFNBQU8sUUFBUSxHQUFSLENBekIyRDtDQUFqRDs7QUE0Qm5CLE9BQU8sT0FBUCxHQUFpQixVQUFqQiIsImZpbGUiOiJzdXBlcnZpc29yLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgY29wcGVyID0gcmVxdWlyZSgnQHJlbGlua2xhYnMvY29wcGVyJyk7XG52YXIgYWN0b3IgPSByZXF1aXJlKCcuL2FjdG9yJyk7XG52YXIgc3VwZXJ2aXNvciA9IHt9O1xuXG4vKlxuICogS2VlcHMgdHJhY2sgb2YgbnVtYmVyIG9mIGVycm9ycyBpbiBhIHJvdyBiZWZvcmUgYW55IHN1Y2Nlc3Nlc1xuICogYW5kIGdyaW5kcyBldmVyeXRoaW5nIHRvIGEgaGFsdCBpZiB0aGUgZXJyb3JzIGV4Y2VlZCB0byBwcm92aWRlZFxuICogbWF4aW11bSBudW1iZXIuXG4gKi9cbnN1cGVydmlzb3IuX3RyYWNrRXJyb3JzID0gZnVuY3Rpb24gX3RyYWNrRXJyb3JzIChtYXhFcnJvcnMpIHtcbiAgdmFyIGVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB2YXIgZXJyb3JzID0gMDtcblxuICBlZS5vbignc3VjY2VzcycsIG1zZyA9PiBlcnJvcnMgPSAwIClcbiAgZWUub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBpZiAoKytlcnJvcnMgPiBtYXhFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ3JpbmQgdGhpcyB3aG9sZSBzaGl0IHRvIGEgaGFsdCcpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qXG4gKiByZWN1cnNpbmcgZnVuY3Rpb24gdGhhdCBmaXJlcyB1cCBhY3RvcnNcbiAqL1xuc3VwZXJ2aXNvci5fc3RhcnRBY3RvcnMgPSBmdW5jdGlvbiBzdGFydEFjdG9ycyhudW0sIHNyYywgZGVzdCwgcmMsIGVlLCBjb25maWcsIGVuZENiKSB7XG4gIGlmIChudW0gPT09IDApIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgYWN0b3JcbiAgICAuc3RhcnQoc3JjLCBkZXN0LCBjb25maWcudHJhbnNmb3JtKVxuICAgIC5vbignc3VjY2VzcycsIG1zZyA9PiBlZS5lbWl0KCdzdWNjZXNzJywgbXNnKSlcbiAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlRXJyb3JzIChlcnIpe1xuXG4gICAgICAvLyB3cml0ZSBtZXNzYWdlIGJhY2sgdG8gdGhlIHJlY3ljbGUvZXJyb3IgcXVldWVcbiAgICAgIHZhciBpbnB1dCA9IGVyci5vcmlnaW5hbElucHV0O1xuICAgICAgcmMud3JpdGUoaW5wdXQpIHx8IHJjLm9uY2UoJ2RyYWluJywgcmMud3JpdGUoaW5wdXQpKTtcblxuICAgICAgLy8gd3JpdGUgdG8gdGhlIGVycm9yIHN0cmVhbSBhbmQgcmVjdXJzZSB0byByZXN0YXJ0IGEgc2luZ2xlIGFjdG9yLlxuICAgICAgZWUuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgc3RhcnRBY3RvcnMoMSwgc3JjLCBkZXN0LCByYywgZWUsIGNvbmZpZywgIGVuZENiKTtcbiAgICB9KVxuICAgIC5vbignZW5kJywgZW5kQ2IpO1xuXG4gIHN0YXJ0QWN0b3JzKC0tbnVtLCBzcmMsIGRlc3QsIHJjLCBlZSwgY29uZmlnLCBlbmRDYik7XG59O1xuXG4vKlxuICogS2VlcHMgdHJhY2sgb2YgZmluaXNoZWQgYWN0b3JzLCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbFxuICogc3RhcnRlZCBhY3RvcnMgc3VjY2VzZnVsbHkgZW5kLlxuICovXG5zdXBlcnZpc29yLl9ydW5Qcm94aWVzID0gZnVuY3Rpb24gcnVuUHJveGllcyAoc3JjLCBkZXN0LCBjb25maWcsIHJjKSB7XG4gIHZhciBudW0gPSBjb25maWcubnVtYmVyO1xuICB2YXIgZXJyb3JDb3VudCA9IGNvbmZpZy5lcnJvckNvdW50IHx8IDEwO1xuICB2YXIgcmVzb2x2ZTtcblxuICBpZiAoIW51bSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcgb2JqZWN0IG11c3QgaW5jbHVkZSB0aGUgbnVtYmVyIG9mIHdvcmtlcnMgdG8gc3RhcnQhJylcbiAgfVxuXG4gIHZhciBlbmRDYiA9ICgpID0+IC0tbnVtIDwgMSAmJiByZXNvbHZlKCk7XG4gIHZhciBlZSA9IHN1cGVydmlzb3IuX3RyYWNrRXJyb3JzKGVycm9yQ291bnQpO1xuICBzdXBlcnZpc29yLl9zdGFydEFjdG9ycyhudW0sIHNyYywgZGVzdCwgcmMsIGVlLCBjb25maWcsIGVuZENiKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHJlc29sdmUgPSBfcmVzb2x2ZSk7XG59O1xuXG5cbi8qKlxuICogU3VwZXJ2aXNvciBzdGFydHMgYWN0b3JzLCBydW5uaW5nIHRoZSBwcm94eSBhY3RvciBwcm9jZXNzZXMsIG1vbml0b3JpbmdcbiAqIHRoZW0gdG8gc2VlIHdoZW4gdGhleSBhcmUgZWl0aGVyIGFsbCBmaW5pc2hlZCwgb3IgaGF2ZSBleGNlc3NpdmUgZXJyb3JzLiBJZiB0aGV5XG4gKiBoYXZlIGV4Y2Vzc2l2ZSBlcnJvcnMsIHRoZSBzdXBlcnZpc29yIHdpbGwgaW50ZW50aW9uYWxseSB0aHJvdyBhbmQgc3RvcCB0aGUgc3lzdGVtLlxuICogV2hlbiB0aGV5IGNvbWUgdG8gdGhlIGVuZCBvZiB0aGVpciBxdWV1ZSwgdGhlIHN1cGVydmlzb3Igd2lsbCB3YWl0IHVudGlsIHRoZSBxdWV1ZVxuICogc3RhcnRzIGFnYWluLCB0aGVuIHN0YXJ0IHRoZW0gdXAgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBudW1iZXIgPSBudW1iZXIgb2YgYWN0b3JzIHRvIHN0YXJ0LFxuICogdHJhbnNmb3JtID0gdHJhbnNmb3JtIVxuICogZXJyb3JDb3VudCA9IGFtb3VudCBvZiBlcnJvcnMgaW4gYSByb3cgYmVmb3JlIGl0IHNodXRzIGRvd25cbiAqIEBwYXJhbSB7U3RyZWFtfSByYyBvcHRpb25hbCByZWN5Y2xlIHN0cmVhbSBmb3IgbWVzc2FnZXMgdGhhdCBlcnJvcmVkLlxuICogQHBhcmFtIHtTdHJlYW19IHNyYyBmb3IgdXNlIG9ubHkgaWYgbm90IHBpcGluZywgdGhlbiBpdHMgdGhlIHNyYyBzdHJlYW0uXG4gKiBAcGFyYW0ge1N0cmVhbX0gZGVzdCBmb3IgdXNlIG9ubHkgaWYgbm90IHBpcGluZywgdGhlbiBpdHMgdGhlIGRlc3Qgc3RyZWFtXG4gKiBAcmV0dXJucyB7U3RyZWFtfSBEdXBsZXggU3RyZWFtIHRoYXQgY2FuIGJlIHBpcGVkIGludG8gYW5kIG91dCBvZlxuICovXG5zdXBlcnZpc29yLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnRTdXBlcnZpc29yIChjb25maWcsIHJjLCBzcmMsIGRlc3QpIHtcblxuICAvLyBpZiB3ZSBhcmUgcGFzc2VkIGluIGEgcmVhZGFibGUgc3RyZWFtLCByYXRoZXIgdGhhbiBjcmVhdGluZyBvbiBvdXJzZWx2ZXMsXG4gIC8vIHRoZSB1c2VyIG1pZ2h0IHBhc3MgaXQgaW4gaW4gZmxvdyBtb2RlLCB3aGljaCB3ZSBkb24ndCB3YW50LCBzbyB3ZSBzdG9wIGl0LlxuICBzcmMgJiYgIXNyYy5pc1BhdXNlZCgpID8gc3JjLnBhdXNlKCkgOiBudWxsO1xuXG4gIC8vIGlmIHdlIGFyZSBub3QgZ2l2ZW4gc3RyZWFtcyBkaXJlY3RseSwgdGhlbiB3ZSdyZSBiZWluZyBwaXBlZCwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBjcmVhdGUgcGFzc3Rocm91Z2ggc3RyZWFtcyBzbyB3ZSBoYXZlIGEgcmVhZCgpIGFuZCB3cml0ZSgpXG4gIC8vIGludGVyZmFjZSB3aXRoIHByb3BlciBiYWNrcHJlc3N1cmUgdGhyb3VnaG91dCB0aGUgcmVzdCBvZiBvdXIgcHJvY2Vzcy5cbiAgdmFyIHN0cmVhbXMgPSBjb3BwZXIuZmFub3V0KCk7XG4gIHNyYyA9IHNyYyB8fCBzdHJlYW1zLnNyYztcbiAgZGVzdCA9IGRlc3QgfHwgc3RyZWFtcy5kZXN0O1xuXG4gIHNyYy5vbigncmVhZGFibGUnLCBoYW5kbGVOZXdEYXRhKTtcblxuICBmdW5jdGlvbiBoYW5kbGVOZXdEYXRhICgpIHtcbiAgICBzdXBlcnZpc29yXG4gICAgICAuX3J1blByb3hpZXMoc3JjLCBkZXN0LCBjb25maWcsIHJjKVxuICAgICAgLnRoZW4oKCkgPT4gc3RhcnRTdXBlcnZpc29yKGNvbmZpZywgcmMsIHNyYywgZGVzdCkpXG5cbiAgICAvLyByZW1vdmUgbGlzdGVuZXIgc28gdGhhdCBvdXIgcHJvY2VzcyAgZG9lc24ndCBnZXQgcmVzdGFydGVkXG4gICAgLy8gdW50aWwgYWxsIGFjdG9ycyBoYXZlIGZ1bGx5IHN0b3BwZWQuXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGhhbmRsZU5ld0RhdGEpO1xuICB9O1xuXG4gIHJldHVybiBzdHJlYW1zLmV4dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3VwZXJ2aXNvcjtcbiJdfQ==